## Java基础语法

### 变量类型Integer和int
> 装箱，例：Integer i = 10，自动将基本数据类型转换为包装器类型, 翻译成: Integer j = Integer.valueOf(10)，在范围-128~127内进行缓存  

> 拆箱，例：int n = i; 自动将包装器类型转换为基本数据类型
1. int与Integer（无论是否new）相比，Integer都会自动拆箱与int相比，都相等；  
2. Integer（常量池）和new Integer对象（堆中）相比，永远不相等；
3. 两个非new的Integer对象相比，在-128~127中缓存，这个范围则相等；
4. 两个new出来的Integer永远不相等，在堆中的不同位置；
5. 在==比较时只会经历拆箱过程，在=赋值时会出现同时装箱和拆箱过程

### String, StringBuilder and StringBuffer区别
1. 可变性（mutable）
+ String不可变
- StringBuilder和StringBuffer可变

2. 线程安全（thread-safe）
* String不可变，因此是线程安全的
* StringBuilder不是线程安全的
* StringBuffer是线程安全的，内部使用synchronized进行同步  

注：因此在单线程应用中使用StringBuilder更好，相比StringBuffer更高效

### "=="和equals的区别

#### Java中的数据类型与"=="
+ 基本数据类型（byte,short,char,int,long,float,double,boolean）之间的比较是比较他们的值；
- 引用数据类型用"=="比较的时候是比较他们在（堆）内存中的存放地址  

注：对于第二种类型，若为同一个new出来的对象，则比较结果为true；否则为false。因为没new一个对象都会重新开辟新的堆内存空间

#### equals()方法
复合数据类型之间进行equals比较，在没有覆盖方法的情况下，他们之间的比较还是内存中存放位置的地址值，与"=="的结果是一样的   
即“内容比较”，可以理解为引用对象的值的"=="比较（个人理解）

### 关键字final

#### 修饰类
```java
final class cls {}
```
1. final修饰一个类，表明这个类不能被继承
2. final类的所有成员方法都会被隐式指定为final（即不会被覆盖）

#### 修饰方法
```java
public final void fun() {}
```
1. 表明这个方法不会被覆盖（override）
2. 可以重载final修饰的方法
3. 所有private方法都会隐式地指定为final


#### 修饰变量
```java
final String s = "a"; //基本数据类型
final Object o = new Object(); //引用类型
```
1. 修饰基本数据类型的变量，其值在初始化之后便不能更改；
2.修饰引用类型的变量，引用不会变，但引用的对象可以改变，因此必须在定义或者构造器中进行初始化赋值

#### final参数
在方法范围内，final参数的值或引用的对象无法被修改，这一特性主要来自匿名内部类传递数据，匿名类所有所有变量都必须是final变量

---
### Collection 类
> 最基本的集合接口，一个Collection代表一组Object

#### 继承体系
Collection
1. List  有序(存储顺序和取出顺序一致)，可重复  
|----- ArrayList ，线程不安全，底层使用数组实现，查询快，增删慢，效率高  
|----- LinkedList ， 线程不安全，底层使用链表实现，查询慢，增删快，效率高  
|----- Vector ， 线程安全，底层使用数组实现，查询快，增删慢，效率低。每次容量不足时，默认自增长度的一倍（如果不指定增量的话）  

2. Set   元素唯一一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素  
|----- HashSet 底层是由HashMap实现的，通过对象的hashCode方法与equals方法来保证插入元素的唯一性，无序(存储顺序和取出顺序不一致)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|-----LinkedHashSet 底层数据结构由哈希表和链表组成。哈希表保证元素的唯一性，链表保证元素有序。(存储和取出是一致)  
|----- TreeSet需要将元素排序

|接口|应用场景|
|:---:|:----:|
Collection|需要保存若干个使用对象时
List|需要保留存储顺序，并且保留重复元素
Set|不需要保留存储顺序，并且需要去掉重复元素

---
### 继承

#### extends和implements
> extends继承（实现）父类，可以覆盖父类定义的变量或函数

> implements继承（实现）父类，不可以覆盖父类定义的变量或函数，即使定义了相同的变量或函数也会被父类取代

extends和implements的区别 
+ extends：若是继承父类，不能多继承，但接口可以多继承（extends）接口 
- implements：一个类实现继承（实现）接口

#### 关键字super和this
+ super：实现对父类成员的访问
- this：指向自己的引用

#### 关键字final
final关键字修饰的类不能被继承  

#### Java的单继承和多继承
+ 类是单继承的（假如多个父类中有相同的方法，则子类无法判断使用哪个父类的方法）
- 接口是多继承的（接口全是抽象方法）

---

### 重写

>子类对父类允许访问的方法重新编写实现过程

主要遵循“两同一大一小”的原则：  
1. “两同”——即方法名、形参类型相同；
2. “一大”——子类方法的访问修饰符(访问权限递减:public->protected->private)应比父类方法更大或相等；
3. “一小”——子类方法声明抛出的异常比父类方法声明抛出的异常更小或相等。

注：关于返回值，在Java7以后可以不同，但要求重写方法的返回值必须是父类返回值的派生类

父类的引用调用子类的对象，例：
```
BasClass a = new SubClass();
```
a是父类的引用指向子类的对象，只能访问父类的属性和方法，可以访问子类重写父类的方法；若需要访问父类被重写的方法，需要在子类重写的方法中加上Super关键字进行调用。


---

### Java多线程

#### 概念：同步和异步、阻塞与非阻塞
> 同步与异步关注的是消息通信机制
+ 同步：调用者发出调用，没有得到调用结果之前，不会返回
- 异步：调用者在发出调用后即使没有得到调用结果也可以返回，被调用这通过状态、通知来进行回调

> 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态
+ 阻塞：在调用结果返回之前，当前线程会被挂起，只有得到调用结果之后才会返回
- 非阻塞：在调用结果返回之前，当前线程不会被阻塞，可以做其他的操作

---

### Java 序列化

Java序列化是一种用来处理对象流（流化对象内容）的机制，主要有两个目的
1. 把对象的字节序列永久保存到硬盘上，通常放在一个文件中
2. 在网络上传送对象的字节序列

#### Serializable接口
虽然可以简单的通过implements Serializable实现序列化，但这样做会有几个缺点
1. 一旦这个类被发布，就大大降低了“改变这个类的实现”的灵活性  
如果接受了默认的序列化形式，这个类的私有的和包级私有的实例域都将编程导出API的一部分，这就失去了作为信息隐藏工具的有效性；
并且之后要改变这个类的内部表示法，结果可能导致序列化形式的的不兼容。

2. 增加了出现bug和安全漏洞的可能性

3. 随着类发行新的版本，相关的测试负担也会增加

为了继承而设计的类，应该尽可能少地去实现Serializable接口，用户的接口也应该尽可能少地继承Serializable接口；
内部类(inner class)不应该实现Serializable，静态成员类（static member class）却可以实现Serializable接口

#### serialVersionUID字段
> 唯一标识符，若没有显式指定，系统会自动生成，受类名、实现的接口名和公有和受保护成员的名称影响，类的兼容性会被破坏

Java的序列化机制是通过在运行时判断类的serialVersionUID来验证一致性的在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地实体（类）的serialVersionUID进行比较,相同就认为是一致的

两种生成方式
+ 默认的1L，如：`private static final long serialversionUID = 1L; `
- 根据类命、接口名、成员方法及属性等生成一个64位的Hash字段(xxxxL)

#### 对象的读写

+ Java类中对象的序列化工作是通过ObjectInputStream和ObjectOutputStream来完成的
- 使用readObject()和writeObject()来实现对象的读写操作，对于基本数据类型，例如int，而已用readInt()和writeInt()接口实现，其他基本类型类似

注：对象读取的顺序必须与写入的顺序相同

#### transient关键字

如果某个实例或对象不能或不应该被序列化，则可以用transient关键字进行标记（Spring中可以是添加@Transient注解）,以跳过序列化过程  

注：若有不能被序列化的对象而没有标注transient关键字，则会抛出NotSerializableException异常

---

### Java 反射
> 反射最重要的用途是开发各种通用框架

### 主要提供以下功能
> 在运行时而不是编译时  

1. 在运行时判断任意一个对象所属的类 
2. 构造任意一个类的的对象
3. 判断任意一个类所具有的成员变量和方法
4. 调用任意一个对象的方法


---

## Java性能调优

#### 主要的几大板块
1. 应用层需要理解代码逻辑，通过Java线程栈定位问题代码；
2. 数据库层需要分析SQL、定位死锁；
3. 框架层需要读懂源代码，理解框架机制；
4. JVM层需要对GC的类型和工作机制有深入的了解。

