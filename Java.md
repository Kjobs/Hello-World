## Java基础语法

### 变量类型Integer和int
> 装箱，例：Integer i = 10，自动将基本数据类型转换为包装器类型, 翻译成: Integer j = Integer.valueOf(10)，在范围-128~127内进行缓存  

> 拆箱，例：int n = i; 自动将包装器类型转换为基本数据类型
1. int与Integer（无论是否new）相比，Integer都会自动拆箱与int相比，都相等；  
2. Integer（常量池）和new Integer对象（堆中）相比，永远不相等；
3. 两个非new的Integer对象相比，在-128~127中缓存，这个范围则相等；
4. 两个new出来的Integer永远不相等，在堆中的不同位置；
5. 在==比较时只会经历拆箱过程，在=赋值时会出现同时装箱和拆箱过程

---
### Collection 类
> 最基本的集合接口，一个Collection代表一组Object

#### 继承体系
Collection
1. List  有序(存储顺序和取出顺序一致)，可重复  
|----- ArrayList ，线程不安全，底层使用数组实现，查询快，增删慢，效率高  
|----- LinkedList ， 线程不安全，底层使用链表实现，查询慢，增删快，效率高  
|----- Vector ， 线程安全，底层使用数组实现，查询快，增删慢，效率低。每次容量不足时，默认自增长度的一倍（如果不指定增量的话）  

2. Set   元素唯一一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素  
|----- HashSet 底层是由HashMap实现的，通过对象的hashCode方法与equals方法来保证插入元素的唯一性，无序(存储顺序和取出顺序不一致)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|-----LinkedHashSet 底层数据结构由哈希表和链表组成。哈希表保证元素的唯一性，链表保证元素有序。(存储和取出是一致)  
|----- TreeSet需要将元素排序

|接口|应用场景|
|:---:|:----:|
Collection|需要保存若干个使用对象时
List|需要保留存储顺序，并且保留重复元素
Set|不需要保留存储顺序，并且需要去掉重复元素

---
### 继承

#### extends()
> 继承（实现）父类，可以覆盖父类定义的变量或函数

#### implements()
> 继承（实现）父类，不可以覆盖父类定义的变量或函数，即使定义了相同的变量或函数也会被父类取代

#### extends和implements的区别 
+ extends：若是继承父类，不能多继承，但接口可以多继承（extends）接口 
- implements：一个类实现继承（实现）接口

#### 关键字super和this
+ super：实现对父类成员的访问
- this：指向自己的引用

#### 关键字final
final关键字修饰的类不能被继承

#### Java的单继承和多继承
+ 类是单继承的（假如多个父类中有相同的方法，则子类无法判断使用哪个父类的方法）
- 接口是多继承的（接口全是抽象方法）

---
### Java多线程

#### 概念：同步和异步、阻塞与非阻塞
> 同步与异步关注的是消息通信机制
+ 同步：调用者发出调用，没有得到调用结果之前，不会返回
- 异步：调用者在发出调用后即使没有得到调用结果也可以返回，被调用这通过状态、通知来进行回调

> 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态
+ 阻塞：在调用结果返回之前，当前线程会被挂起，只有得到调用结果之后才会返回
- 非阻塞：在调用结果返回之前，当前线程不会被阻塞，可以做其他的操作


---
### Java 序列化

#### Java序列化主要有两个目的
1. 把对象的字节序列永久保存到硬盘上，通常放在一个文件中
2. 在网络上传送对象的字节序列

#### serialVersionUID字段
> 用来表明类的不同版本间的兼容性

Java的序列化机制是通过在运行时判断类的serialVersionUID来验证一致性的在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地实体（类）的serialVersionUID进行比较,相同就认为是一致的

两种生成方式
+ 默认的1L，如：`private static final long serialversionUID = 1L; `
- 根据类命、接口名、成员方法及属性等生成一个64位的Hash字段(xxxxL)

---

### Java 反射
> 反射最重要的用途是开发各种通用框架

### 主要提供以下功能
> 在运行时而不是编译时  

1. 在运行时判断任意一个对象所属的类 
2. 在运行时构造任意一个类的的对象
3. 在运行时判断任意一个类所具有的成员变量和方法
4. 在运行时调用任意一个对象的方法


---

## Java性能调优

#### 主要的几大板块
1. 应用层需要理解代码逻辑，通过Java线程栈定位问题代码；
2. 数据库层需要分析SQL、定位死锁；
3. 框架层需要读懂源代码，理解框架机制；
4. JVM层需要对GC的类型和工作机制有深入的了解。

